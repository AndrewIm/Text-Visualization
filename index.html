<meta charset="utf-8">
<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  <script src="https://d3js.org/d3.v3.js"></script>
    
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="js/hashtable.js"></script>
    <script src="js/d3cloud.js"></script>
    <script src="js/d3-tooltip.js"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
     <link rel="stylesheet" href="css/app.css">
  <script>
    $(document).ready(function() {
      $('#showRelationships').on('click', function()  {
        var isChecked = $(this).prop("checked");
        
        // If checked, hide tag cloud and show relationships.  If not, then hide relationships and show tag cloud.
        if(isChecked) {
          $("#tagCloud").removeClass("active").addClass("inactive");
          $("#relationshipChart").addClass("active").removeClass("inactive");
          $("#termRelationship").attr("disabled", false);
        } else {
          $("#tagCloud").addClass("active").removeClass("inactive");
          $("#relationshipChart").removeClass("active").addClass("inactive");
          $("#termRelationship").attr("disabled", true);
        }
      });
    });
  </script>
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>Text Visualization</title>
</head>

<body>
  <h1>Text Visualization</h1>
  <div id="visualizations">
    <div id="options">
      <input type="checkbox" id="showRelationships"> Show Relationships for term: <input type="text" id="termRelationship" disabled><br>
    </div>
    <div id="tagCloud" class="active">
    </div>
    <div id="relationshipChart" class="inactive">
      <p>Relationship chart here.</p>
    </div>
    <div id="timeline">
    </div>
    <div id="intervalSlider">
      <p>Time interval slider here.</p>
    </div>
  </div>
</body>

<script>
  //tag cloud logic
  {
    //cloud svg width and height
    var cloudWidth = 600;
    var cloudHeight = 500;
    var svg = d3.select("#tagCloud").append("svg")
                    .attr("width", cloudWidth)
                    .attr("height", cloudHeight)
                  .append("g")
                    .attr("transform", "translate(" + cloudWidth / 2 + "," + cloudHeight / 2 + ")")

    /* Initialize tooltip */
    var wordTip = d3.tip()
      .attr('class', 'd3-tip')
      .offset([-10, 0])
      .html(function (d) {
          return "<strong>" + d.text + " :" + d.frequency + "</strong>";
      });
    svg.call(wordTip);

    var parseDate = d3.time.format("%Y %m").parse;
    
    var topTerms;
    //HashTable to store the data with TERM as a key
    var allTerms = new Hashtable();
    $(document).ready(function () {
        var termsData;
        //get frequency data
        d3.json("data/termsfrequency.json", function (data) {
            var termsData = data;
            data.forEach(function (d) {
                d.properties.monthfreq.forEach(function(d) {
                  d.month = parseDate(d.month);
                });
                allTerms.put(d.term, d.properties)
            });
            var temp = allTerms.entries();
            temp.sort(function (a, b) {
                return b[1].frequency - a[1].frequency;
            })
            //
            //get top 50 terms
            topTerms = temp.slice(0, 50)
            var fill = d3.scale.category20();
            var sizeScale = d3.scale.linear()
                    .domain([250, d3.max(topTerms, function (d) { return d[1].frequency })])
                    .range([5, 85]);
            var layout = d3.layout.cloud()
                .size([600, 500])
                .words(topTerms.map(function (d) {
                    return { text: d[0], size: d[1].frequency / 15, frequency: d[1].frequency };
                }))
                .padding(5)
                .rotate(function () { return ~~(Math.random() * 2) * 90; })
                .font("Impact")
                .fontSize(function (d) { return sizeScale(d.frequency); })
                .on("end", draw);


            layout.start();

            // Create streamgraph timeline.
            var stack = d3.layout.stack().offset("wiggle")
                        .values(function(d){ return d[1].monthfreq; })
                        .x(function(d){ return d.month; })
                        .y(function(d){ return d.freq; });
          
            // Fills in missing dates in 'data'. 'data' must be non-empty.
            // Assumes that 'data' is sorted by date in reverse-chronological order.
            function fillData(data, startDate, endDate) {
              var d = [],
                  len = data.length,
                  now = new Date(startDate),
                  last = new Date(endDate),
                  iterator = 0,
                  y;
              
              while (now >= last) {
                y = 0;
                if (now.getTime() == new Date(data[iterator].month).getTime()) {
                  y = data[iterator].freq;
                  ++iterator;
                }
                d.push({"month": new Date(now), "freq": y});
                now["setMonth"](now.getMonth() - 1);
              }
              
              return d;
            }
          
            var startDate = d3.max(topTerms, function(d) {
              var localMax = d3.max(d[1].monthfreq, function(d) { return d.month; });
              return localMax;
            });
            
            var endDate = d3.min(topTerms, function(d) {
              var localMin = d3.min(d[1].monthfreq, function(d) { return d.month; });
              return localMin;
            });
            
            topTerms.forEach(function(d) {
              d[1].monthfreq = fillData(d[1].monthfreq, startDate, endDate);
            });
          
            // An array of dates in which all frequencies are zero. Used to hide a term
            // in the streamgraph (as opposed to completely deleting it).
            var zeroSeries = [{freq: 0, month: endDate}];
            zeroSeries = fillData(zeroSeries, startDate, endDate);
            
            // Define dimensions.
            var margin = {top: 20, right: 0, bottom: 30, left: 40};
            var svgWidth = $("#timeline").width();
            var svgHeight = $("#timeline").height();
            var width = svgWidth * 0.98 - margin.left - margin.right;
            var height = svgHeight - margin.bottom - margin.top;
          
            // Define scales.
            var timelineX = d3.time.scale()
                .range([0, width]);
          
            var timelineY = d3.scale.linear()
                .range([height, 0]);
          
            // Define axes.
            var xAxis = d3.svg.axis()
                .scale(timelineX)
                .orient("bottom")
                .ticks(5)
                .tickFormat(d3.time.format("%b '%y"));
            
            var yAxis = d3.svg.axis()
                .scale(timelineY)
                .orient("left")
                .ticks(7);
          
            // Define stacked areas and lines that separate the areas.
            var area = d3.svg.area()
                .interpolate("cardinal")
                .x(function(d) { return timelineX(d.month); })
                .y0(function(d) { return timelineY(d.y0); })
                .y1(function(d) { return timelineY(d.y0 + d.y); });
          
            var line = d3.svg.line()
                .interpolate("cardinal")
                .x(function(d) { return timelineX(d.month); })
                .y(function(d) { return timelineY(d.y0); });
          
            var layers = stack(topTerms);
          
            timelineX.domain([endDate, startDate]);
            timelineY.domain([0, d3.max(layers, function(d) {
              var localMax = d3.max(d[1].monthfreq, function(d) { return d.y0 + d.y; });
              return localMax;
            })]);
          
            var timeline = d3.select("#timeline").append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
              .append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
          
            // Define a clip path to prevent the graph from going out of its region on zoom.
            var defs = timeline.append("defs");          
            defs.append("clipPath")
                .attr("id", "sideClip")
              .append("rect")
                .attr("transform", "translate(0,-" + margin.top + ")")
                .attr("width", width)
                .attr("height", height + margin.top);
          
            // Stacked layers.
            timeline.selectAll(".layer")
                .data(layers)
              .enter().append("path")
                .attr("clip-path", "url(#sideClip)")
                .attr("class", "layer")
                .call(updateLayer);
          
            // Lines separating stacked layers.
            timeline.selectAll(".layerLine")
                .data(layers)
              .enter().append("path")
                .attr("clip-path", "url(#sideClip)")
                .attr("class", "layerLine")
                .call(updateLayerLine);
            
            // Add axes.
            timeline.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);
          
            timeline.append("g")
                .attr("class", "y axis")
                .call(yAxis);
          
            // Zoom demo.
            /*
            endDate.setYear(2005);
            timelineX.domain([endDate, startDate]);
          
            timeline.selectAll(".layer")
                .data(layers)
                .transition()
                .duration(2000)
                .call(updateLayer);
            
            timeline.selectAll(".layerLine")
                .data(layers)
                .transition()
                .duration(2000)
                .call(updateLayerLine);
                
            timeline.select(".x.axis")
                .transition()
                .duration(2000)
                .call(xAxis);
          
            timeline.select(".y.axis")
                .transition()
                .duration(2000)
                .call(yAxis);
            */
          
            // Updates the stacked layers with their current data.
            function updateLayer() {
              this.attr("d", function(d) { return area(d[1].monthfreq); })
                .style("fill", function(d, i) { return fill(i); });
            }
            
            // Updates the lines with their current data.
            function updateLayerLine() {
              this.attr("d", function(d) { return line(d[1].monthfreq); });
            }

            function draw(words) {
                svg.selectAll("text")
                  .data(words)
                .enter().append("text")
                  .style("font-size", function (d) { return d.size + "px"; })
                  .style("font-family", "Impact")
                  .style("fill", function (d, i) { return fill(i); })
                    .style("cursor", "pointer")
                    .style("pointer-events", "all")
                  .attr("text-anchor", "middle")
                  .attr("transform", function (d) {
                      return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
                  })
                    .attr("class", "cloud-terms")
                    .text(function (d) { return d.text; })
                    .on("mousemove", function (d) {
                        //  d3.select(this).attr("opacity", "0.6");
                        wordTip.show(d);
                    })
                    .on("mouseout", function (d) {
                        d3.select(this).attr("opacity", "1");
                        wordTip.hide();
                    })
                    .on("click", function (d) {
                        //Click Logic goes here
                        svg.selectAll(".cloud-terms")
                                .style("fill", function (d1, i) {
                                    if (d.text == d1.text)
                                        d1.active = !d1.active;
                                    if (d1.active == undefined || d1.active == false)
                                        return "grey";
                                    else
                                        return fill(i);
                                })
                        //get Month Freq 
                        $("#overviewTimeline").empty();
                        $("#overviewTimeline").append("Selected word :" + d.text + "</br>");
                        var result = getMonthFreq(d.text);
                        result.forEach(function (d) {
                            $("#overviewTimeline").append(d.month + " " + d.freq.toString() + "</br>");
                        })
                    });
            }
        });
    });
    function getMonthFreq(term) {
        var termDetails = allTerms.get(term);
        var result = [];
        var Months = termDetails.monthfreq;
        $("#overviewTimeline").append("Total Frequency :" + termDetails.frequency + "</br>");
        Months.forEach(function (d) {
            result.push({ "month": d.month, "freq": d.freq })
        });
        return result;

    }
  }
</script>