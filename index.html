<meta charset="utf-8">
<head>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  <script src="https://d3js.org/d3.v3.js"></script>

  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="js/hashtable.js"></script>
  <script src="js/d3cloud.js"></script>
  <script src="js/d3-tooltip.js"></script>
  <script src="js/terms-generator.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <link rel="stylesheet" href="css/app.css">
  <script>
    $(document).ready(function () {
      $('#showRelationships').on('click', function () {
        var isChecked = $(this).prop("checked");

        // If checked, hide tag cloud and show relationships.  If not, then hide relationships and show tag cloud.
        if (isChecked) {
          $("#tagCloud").removeClass("active").addClass("inactive");
          $("#relationshipChart").addClass("active").removeClass("inactive");
          $("#termRelationship").attr("disabled", false);
        } else {
          $("#tagCloud").addClass("active").removeClass("inactive");
          $("#relationshipChart").removeClass("active").addClass("inactive");
          $("#termRelationship").attr("disabled", true);
        }
      });
    });
  </script>
  <link rel="stylesheet" type="text/css" href="style.css">
  <title>Text Visualization</title>
</head>

<body>
  <h1>Text Visualization</h1>
  <div id="visualizations">
    <div id="options">
      <input type="checkbox" id="showRelationships">
      <input type="radio" name="Source" id="wiki" checked onclick="setSource('wiki')">Wikinews
      <input type="radio" name="Source" id="HP" onclick="setSource('hp')">Huffinton
      <input type="text" style="width: 40px" id="texttermscount" placeholder="count" value="50">
      Show Relationships for term:
            <input type="text" id="termRelationship" disabled><br>
      <div class="row">
        <div class="col col-md-6">
          <select id="fromMonth" placeholder="From Month">
            <option>01</option>
            <option>02</option>
            <option>03</option>
            <option>04</option>
            <option>05</option>
            <option>06</option>
            <option>07</option>
            <option>08</option>
            <option>09</option>
            <option>10</option>
            <option>11</option>
            <option>12</option>
          </select>
          <select id="fromYear" placeholder="From Year">
            <option>2004</option>
            <option>2005</option>
            <option>2006</option>
            <option>2007</option>
            <option>2008</option>
            <option>2009</option>
            <option>2010</option>
            <option>2011</option>
            <option>2012</option>
            <option>2013</option>
            <option>2014</option>
            <option>2015</option>
          </select>
          To
        <select id="toMonth" placeholder="To Month">
          <option>01</option>
          <option>02</option>
          <option>03</option>
          <option>04</option>
          <option>05</option>
          <option>06</option>
          <option>07</option>
          <option>08</option>
          <option>09</option>
          <option>10</option>
          <option>11</option>
          <option>12</option>
        </select>
          <select id="toYear" placeholder="From Year">
            <option>2004</option>
            <option>2005</option>
            <option>2006</option>
            <option>2007</option>
            <option>2008</option>
            <option>2009</option>
            <option>2010</option>
            <option>2011</option>
            <option>2012</option>
            <option>2013</option>
            <option>2014</option>
            <option>2015</option>
          </select>
          <button onclick="updateData()">Go</button>
        </div>
      </div>
      <div id="tagCloud" class="active">
      </div>
      <div id="relationshipChart" class="inactive">
        <p>Relationship chart here.</p>
      </div>
      <div id="timeline">
      </div>
      <div id="intervalSlider">
        <p>Time interval slider here.</p>
      </div>
    </div>
</body>

<script>
  var source = "wn";
  var topTermsCount = 50;
  function setSource(s) {
    if (s == "wiki") {
      source = "wn";
      allTermsArray = wnallTermsArray;
      allTermsMap = wnallTermsMap;
      topTerms = getTopTerms();
      showNewWords(myWordCloud, topTerms);
      //update stream graph, topterms.monthfreq contains monthly frequency
      updateStreamGraph(topTerms)
    }
    else {
      source = "hp"
      allTermsArray = hpallTermsArray;
      allTermsMap = hpallTermsMap;
      topTerms = getTopTerms();
      showNewWords(myWordCloud, topTerms);
      //update stream graph, topterms.monthfreq contains monthly frequency
      updateStreamGraph(topTerms)
    }

  }
  $('#texttermscount').bind('input propertychange', function () {
    topTermsCount = $('#texttermscount').val();

  })

  $('#texttermscount').focusout(function () {
    topTermsCount = $('#texttermscount').val();
    $("#tagCloud").addClass("loading");
    setTimeout(function () {
      updateVisualization();
      svg.selectAll(".cloud-terms").style("fill", function (d, i) {

        return fill(i);

      })
      $("#tagCloud").removeClass("loading");
    }, 0);
  })

  // stream graph variables declared globally to keep the scope for update
  var stack;
  var startDate;
  var endDate;
  var area;
  var line;
  var layers;
  var timeline;
  var defs;
  var timelineX
  var timelineY;
  var xAxis, yAxis;

  // Method for creating stack layout.
  stack = d3.layout.stack().offset("wiggle")
              .values(function (d) { return d.monthfreq; })
              .x(function (d) { return d.month; })
              .y(function (d) { return d.freq; });
  
  //Mouse click delay variables
  var DELAY = 300, clicks = 0, timer = null;
  //Global Variable to hold the data
  var allTermsMap;
  var allTermsArray = [];
  var wnallTermsMap;
  var wnallTermsArray = [];
  var hpallTermsMap;
  var hpallTermsArray = [];

  // An array of dates in which all frequencies are zero. Used to hide a term
  // in the streamgraph (as opposed to completely deleting it).
  var zeroSeries = [{ freq: 0, month: endDate }];
  zeroSeries = fillData(zeroSeries, startDate, endDate);

  //cloud svg width and height
  var cloudWidth = $("#tagCloud").width();
  var cloudHeight = $("#tagCloud").height();
  var svg = d3.select("#tagCloud").append("svg")
          .attr("width", cloudWidth)
          .attr("height", cloudHeight)
          .append("g")
          .attr("transform", "translate(" + cloudWidth / 2 + "," + cloudHeight / 2 + ")")

  /* Initialize tooltip */
  var wordTip = d3.tip()
          .attr('class', 'd3-tip')
          .offset([-10, 0])
          .html(function (d) {
            return "<strong>" + d.text + " :" + d.frequency + "</strong>";
          });
  svg.call(wordTip);
  var parse = d3.time.format("%Y %m");
  var start = parse.parse("2004 01");
  var end = parse.parse("2015 12");
  var topTerms;
  var myWordCloud;
  var fill = d3.scale.category20();
  var brush;
  var sizeScale = d3.scale.linear()
          .range([5, 80]);
  $(document).ready(function () {
    var termsData;
    //Create a new instance of the word cloud visualisation.
    myWordCloud = wordCloud('#tagCloud');
    loadData("data/wikinews.tsv", "wn")
    loadData("data/huffington.tsv", "hp")
  });

  function loadData(filename, source) {
    var localallTermsArray = [];
    var localallTermsMap;
    var data = preProcessData();
    data.startProcess(filename, function (data) {

      localallTermsMap = data;
      var monthly = [];
      var currmonth;
      for (var term in data) {
        monthly = []
        var entry = {};
        entry.term = term;
        entry.values = {};
        for (var val in data[term]) {
          if (val == "frequency") {
            entry.values.frequency = data[term][val];
          }
          else {
            currmonth = parse.parse(val);
            monthly.push({
              "month": currmonth,
              "freq": data[term][val].freq,
              "blogs": data[term][val].blogs
            })
          }
        }
        entry.values.monthfreq = monthly;


        localallTermsArray.push(entry)
      }

      if (source == "wn") {
        wnallTermsArray = localallTermsArray;
        wnallTermsMap = localallTermsMap;
        allTermsArray = wnallTermsArray;
        allTermsMap = wnallTermsMap
        topTerms = getTopTerms();
        showNewWords(myWordCloud, topTerms);
        //Set stream graph, topterms.monthfreq contains monthly frequency
        setStreamGraph();
      }
      else {
        hpallTermsArray = localallTermsArray;
        hpallTermsMap = localallTermsMap;
      }


    });
  }

  //getTopTerms based on start and end dates
  function getTopTerms() {
    var monthlyData = [];
    var topTerms;
    var currmonth;
    var blogs = [];
    var monthfreq = [];
    allTermsArray.forEach(function (d, i) {
      var months = d.values.monthfreq;
      var freq = 0;
      blogs = [];
      monthfreq = [];
      for (var i = 0; i < months.length; i++) {
        currmonth = months[i].month;
        if (currmonth >= start && currmonth <= end) {
          freq = freq + months[i].freq;

          months[i].blogs.forEach(function (b) {
            blogs.push(b);

          })
          monthfreq.push(months[i]);
        }
      }
      if (freq > 0)
        monthlyData.push({ "term": d.term, "freq": freq, "blogs": blogs, "monthfreq": monthfreq });
    });

    monthlyData.sort(function (a, b) {
      return b.freq - a.freq;
    })
    //
    //get top 50 terms
    topTerms = monthlyData.slice(0, topTermsCount)

    return topTerms;
  }

  function showNewWords(vis, words) {
    vis.update(words)
  }

  // Encapsulate the word cloud functionality
  function wordCloud(selector) {

    //Draw the word cloud
    function draw(words) {

      var cloud = svg.selectAll("g text")
              .data(words, function (d) {
                return d.text;
              })

      //Entering words
      cloud.enter().append("text")
              .style("font-size", function (d) {
                return d.size + "px";
              })
              .style("font-family", "Impact")
              .style("fill", function (d, i) {
                return fill(i);
              })
              .style("cursor", "pointer")
              .style("pointer-events", "all")
              .attr("text-anchor", "middle")
              .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
              })
              .attr("class", "cloud-terms")
              .text(function (d) {
                return d.text;
              })
              .on("mousemove", function (d) {
                //  d3.select(this).attr("opacity", "0.6");
                wordTip.show(d);
              })
              .on("mouseout", function (d) {
                d3.select(this).attr("opacity", "1");
                wordTip.hide();
              })
              //handle single and double clicks
              .on("click", function (d) {
                clicks++;  //count clicks to know the double click
                if (clicks === 1) {
                  timer = setTimeout(function () {
                    //perform single-click action
                    //Click Logic goes here
                    svg.selectAll(".cloud-terms")
                            .style("fill", function (d1, i) {
                              if (d.text == d1.text)
                                d1.active = !d1.active;
                              if (d1.active == undefined || d1.active == false)
                                return "grey";
                              else
                                return fill(i);
                            })
                    clicks = 0;             //after action performed, reset counter

                  }, DELAY);

                } else {
                  clearTimeout(timer);    //prevent single-click action
                  //perform double-click action
                  svg.selectAll(".cloud-terms")

                          .style("fill", function (d1, i) {
                            d1.active = false;
                            if (d.text == d1.text) {
                              d1.active = true;
                              return fill(i);
                            }

                            else
                              return "grey";
                          })
                  clicks = 0;             //after action performed, reset counter
                }

              })

      //Entering and existing words
      cloud.transition()
              .duration(100)
              .style("font-size", function (d) {
                return d.size + "px";
              })
              .attr("transform", function (d) {
                return "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")";
              })
              .style("fill-opacity", 1);

      //Exiting words
      cloud.exit()
              .transition()
              .duration(100)
              .style('fill-opacity', 1e-6)
              .attr('font-size', 1)
              .remove();

    }


    return {
      update: function (words) {
        if ($("#tagCloud").width() > 430)
          sizeScale.range([5, 80]);
        else
          sizeScale.range([4, 60]);
        sizeScale.domain([d3.min(words, function (d) {
          return d.freq
        }), d3.max(words, function (d) {
          return d.freq
        })])

        d3.layout.cloud().size([cloudWidth, cloudHeight])
                .timeInterval(Infinity)
                .words(words.map(function (d) {
                  return { text: d.term, size: sizeScale(d.freq), frequency: d.freq, active: true };
                }))
                .padding(5)
                .rotate(function () {
                  return ~~(Math.random() * 2) * 90;
                })
                .font("Impact")
                .fontSize(function (d) {
                  return d.size
                })
                .on("end", draw)
                .start();
      }
    }
  }

  function updateData() {
    start = parse.parse($('#fromYear').val() + " " + $('#fromMonth').val());
    end = parse.parse($('#toYear').val() + " " + $('#toMonth').val());
    $("#tagCloud").addClass("loading");
    setTimeout(function () {
      updateVisualization();
      svg.selectAll(".cloud-terms").style("fill", function (d, i) {

        return fill(i);

      })
      $("#tagCloud").removeClass("loading");
    }, 0);

  }

  function brushend() {
    start = brush.extent()[0];
    end = brush.extent()[1];

    $("#tagCloud").addClass("loading");
    setTimeout(function () {
      updateVisualization();
      svg.selectAll(".cloud-terms").style("fill", function (d, i) {

        return fill(i);

      })
      $("#tagCloud").removeClass("loading");
    }, 0);

  }

  function updateVisualization() {

    $("#range").text(start.getMonth() + " " + start.getFullYear() + " TO " + end.getMonth() + " " + end.getFullYear());
    var topTerms = getTopTerms();
    showNewWords(myWordCloud, topTerms);
    //update stream graph, topterms.monthfreq contains monthly frequency
    updateStreamGraph(topTerms)
  }

  function setStreamGraph() {
    // TODO(manorepo): Remove below comment.
    // stream code change - Moved the sub functions out of this function to make available for update.

    startDate = d3.max(topTerms, function (d) {
      var localMax = d3.max(d.monthfreq, function (d) { return d.month; });
      return localMax;
    });

    endDate = d3.min(topTerms, function (d) {
      var localMin = d3.min(d.monthfreq, function (d) { return d.month; });
      return localMin;
    });

    topTerms.forEach(function (d) {
      d.monthfreq = fillData(d.monthfreq, startDate, endDate);
    });

    // Define dimensions.
    var margin = { top: 20, right: 0, bottom: 30, left: 40 };
    var svgWidth = $("#timeline").width();
    var svgHeight = $("#timeline").height();
    var width = svgWidth * 0.98 - margin.left - margin.right;
    var height = svgHeight - margin.bottom - margin.top;

    // Define scales.
    timelineX = d3.time.scale()
        .range([0, width]);

    timelineY = d3.scale.linear()
        .range([height, 0]);

    // Define axes.
    xAxis = d3.svg.axis()
        .scale(timelineX)
        .orient("bottom")
        .ticks(5)
        .tickFormat(d3.time.format("%b '%y"));

    yAxis = d3.svg.axis()
        .scale(timelineY)
        .orient("left")
        .ticks(7);

    // Define stacked areas and lines that separate the areas.
    area = d3.svg.area()
        .interpolate("cardinal")
        .x(function (d) { return timelineX(d.month); })
        .y0(function (d) { return timelineY(d.y0); })
        .y1(function (d) { return timelineY(d.y0 + d.y); });

    line = d3.svg.line()
        .interpolate("cardinal")
        .x(function (d) { return timelineX(d.month); })
        .y(function (d) { return timelineY(d.y0); });

    layers = stack(topTerms);

    timelineX.domain([endDate, startDate]);
    timelineY.domain([0, d3.max(layers, function (d) {
      var localMax = d3.max(d.monthfreq, function (d) { return d.y0 + d.y; });
      return localMax;
    })]);

    timeline = d3.select("#timeline").append("svg")
       .attr("width", svgWidth)
       .attr("height", svgHeight)
     .append("g")
     .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Define a clip path to prevent the graph from going out of its region on zoom.
    defs = timeline.append("defs");
    defs.append("clipPath")
        .attr("id", "sideClip")
      .append("rect")
        .attr("transform", "translate(0,-" + margin.top + ")")
        .attr("width", width)
        .attr("height", height + margin.top);

    // Stacked layers.
    timeline.selectAll(".layer")
        .data(layers)
      .enter().append("path")
        .attr("clip-path", "url(#sideClip)")
        .attr("class", "layer")
        .call(updateLayer)
        .on("mouseover", highlightLayer)
        .on("mouseout", unhighlightLayer);

    // Lines separating stacked layers.
    timeline.selectAll(".layerLine")
        .data(layers)
      .enter().append("path")
        .attr("clip-path", "url(#sideClip)")
        .attr("class", "layerLine")
        .call(updateLayerLine);

    // Add axes.
    timeline.append("g")
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    timeline.append("g")
        .attr("class", "y axis")
        .call(yAxis);

    // Zoom demo.
    /*
    endDate.setYear(2005);
    timelineX.domain([endDate, startDate]);
      
    timeline.selectAll(".layer")
        .data(layers)
        .transition()
        .duration(2000)
        .call(updateLayer);
        
    timeline.selectAll(".layerLine")
        .data(layers)
        .transition()
        .duration(2000)
        .call(updateLayerLine);
            
    timeline.select(".x.axis")
        .transition()
        .duration(2000)
        .call(xAxis);
      
    timeline.select(".y.axis")
        .transition()
        .duration(2000)
        .call(yAxis);
    */


  }

  // Fills in missing dates in 'data'. 'data' must be non-empty.
  // Assumes that 'data' is sorted by date in reverse-chronological order.
  function fillData(data, startDate, endDate) {
    var d = [],
        len = data.length,
        now = new Date(startDate),
        last = new Date(endDate),
        iterator = len - 1,
        y;

    while (now >= last) {
      y = 0;
      try {
        // stream code change - changed logic as the data has months in ascending order
        if (iterator >= 0 && now.getTime() == new Date(data[iterator].month).getTime()) {
          y = data[iterator].freq;
          --iterator;
        }
      }
      catch (exc) {
        console.log(iterator);
        debugger;
      }
      d.push({ "month": new Date(now), "freq": y });
      now["setMonth"](now.getMonth() - 1);
    }

    return d;
  }

  function updateStreamGraph(topTerms) {
    startDate = d3.max(topTerms, function (d) {
      var localMax = d3.max(d.monthfreq, function (d) { return d.month; });
      return localMax;
    });

    endDate = d3.min(topTerms, function (d) {
      var localMin = d3.min(d.monthfreq, function (d) { return d.month; });
      return localMin;
    });

    topTerms.forEach(function (d) {
      d.monthfreq = fillData(d.monthfreq, startDate, endDate);
    });

    layers = stack(topTerms);
    timelineX.domain([endDate, startDate]);
    timelineY.domain([0, d3.max(layers, function (d) {
      var localMax = d3.max(d.monthfreq, function (d) { return d.y0 + d.y; });
      return localMax;
    })]);

    // Stacked layers.
    var stackLayers = timeline.selectAll(".layer")
        .data(layers);
    stackLayers.enter().append("path")
        .attr("clip-path", "url(#sideClip)")
        .attr("class", "layer")
        .call(updateLayer)
        .on("mouseover", highlightLayer)
        .on("mouseout", unhighlightLayer);

    // Lines separating stacked layers.
    var layerLines = timeline.selectAll(".layerLine")
        .data(layers);
    layerLines.enter().append("path")
        .attr("clip-path", "url(#sideClip)")
        .attr("class", "layerLine")
        .call(updateLayerLine);
    
    timeline.selectAll(".layer")
        .call(updateLayer);
    
    timeline.selectAll(".layerLine")
        .call(updateLayerLine);

    // Remove layers that should no longer be there.
    stackLayers.exit().remove();
    layerLines.exit().remove();

    // Add axes.

    timeline.select(".x.axis")
        .call(xAxis);

    timeline.select(".y.axis")
        .call(yAxis);

  }

  // Updates the stacked layers with their current data.
  function updateLayer() {
    this.attr("d", function (d) { return area(d.monthfreq); })
      .style("fill", function (d, i) { return fill(i); });
  }

  // Updates the lines with their current data.
  function updateLayerLine() {
    this.attr("d", function (d) { return line(d.monthfreq); });
  }

  function highlightLayer(d) {
    timeline.selectAll(".layer")
        .attr("opacity", function (d1) {
          if (d.term == d1.term) {
            return "1";
          } else {
            return "0.2";
          }
        });
    timeline.selectAll(".layerLine")
        .attr("opacity", function (d1) {
          if (d.term == d1.term) {
            return "1";
          } else {
            return "0.2";
          }
        });
  }

  function unhighlightLayer() {
    timeline.selectAll(".layer")
        .attr("opacity", "1");
    timeline.selectAll(".layerLine")
        .attr("opacity", "1");
  }
</script>
